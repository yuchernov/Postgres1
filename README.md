# Создать индекс к какой-либо из таблиц вашей БД
Создадим таблицу, в которой будет содержаться информация о фильмах. Наполним данными
```
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10)
);
insert into films (code,title,did,date_prod,kind) values ('WEST1','Unforgiven',1999,'1999-03-14','Western');
insert into films (code,title,did,date_prod,kind) values ('WEST2','Unforgiven_2',2000,'2000-03-14','Western');
insert into films (code,title,did,date_prod,kind) values ('DRAM1','Forgiven',2003,'2003-06-14','Drama');
insert into films (code,title,did,date_prod,kind) values ('DRAM2','Forgive_2',2005,'2005-03-14','Drama');
```
Создадим индекс к полю code таблицы films
```
CREATE UNIQUE INDEX code_idx ON films (code);
```
Классческий индекс на основе B дерева. Используется во многих СУБД в качестве основого. Особенно популярен в OLTP системах. 
Позволяет быстро изымать небольшие объемы данных из таблицы, как правило, 3-5% от объема данных. 
В этом кейсе, будет максимально эффективным. 

# Прислать текстом результат команды explain в которой используется данный индекс
```
select * from films where code = 'WEST1'

Index Scan using code_idx on films  (cost=0.13..8.15 rows=1 width=32)
  Index Cond: (code = 'WEST1'::bpchar)
```
# Реализовать индекс для полнотекстового поиска
```
CREATE INDEX pgcode_idx ON films USING GIN (to_tsvector('english', kind));
```
Данный индекс позволит нам осуществить полнотекстовый поиск по полю kind. В запросе это бы выглядело следующим образом:
```
SELECT code
FROM films
WHERE to_tsvector(kind) @@ to_tsquery('Drama');
```

Индексы применяются для поиска вхождения в строку данных. Чем то похож на создание регулярных выражений. Пользователь задает определенную маску, формат. Пользователь с помощью данного индекса может предварительно разбивать текст документа
на составляющие, затем приводить к нужному формату, и в конце концов осуществлять поиск. 

# Реализовать индекс на часть таблицы или индекс на поле с функцией
```
CREATE INDEX title_low_idx ON films ((lower(title)));
```
Функциональные индексы позволяют нам применять различные встроенные функции ,непосредственно, перед извлечением данных. Например, используя lower , мы сможем избежать неточность выборки, в случае некорректного написания слова пользователем. 

# Создать индекс на несколько полей
```
CREATE INDEX title_kind_idx ON films (code, kind);
```
Составные индексы, например, выгодно использовать когда в одной таблице есть пересекающиеся значения. Например, у нас в таблице есть id города, id товара. Id товара в каждом городе начинается с 1, тем самым, мы бы не смогли создать индекс 
только по полю id товара, поскольку он бы не был уникальным, но, подвязав к id товара id города, мы успешно сможем использовать индексный доступ в этой таблице по id. 